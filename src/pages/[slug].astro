---
import { getCollection, getEntry } from "astro:content";
import type { GetStaticPaths } from "astro";
import BlogPost from "../layouts/BlogPost.astro";

export const prerender = true;

export const getStaticPaths: GetStaticPaths = async () => {
  const RESERVED_SLUGS = [
    "now",
    "newsletter",
    "rss.xml",
    "rss",
    "blog",
    "sitemap.xml",
    "robots.txt",
  ];

  const blogEntries = await getCollection("blog", ({ data }) => !data.draft);

  // Collision detection
  const collisions = blogEntries.filter((e) => RESERVED_SLUGS.includes(e.slug));
  if (collisions.length > 0) {
    throw new Error(
      `Blog slugs collide with reserved routes: ${collisions.map((e) => e.slug).join(", ")}`,
    );
  }

  // Duplicate detection
  const slugs = new Map<string, string[]>();
  blogEntries.forEach((e) => {
    if (!slugs.has(e.slug)) slugs.set(e.slug, []);
    slugs.get(e.slug)!.push(e.id);
  });

  const duplicates = Array.from(slugs.entries()).filter(
    ([_, ids]) => ids.length > 1,
  );
  if (duplicates.length > 0) {
    throw new Error(
      `Duplicate blog slugs:\n` +
        duplicates
          .map(([slug, ids]) => `  "${slug}": ${ids.join(", ")}`)
          .join("\n"),
    );
  }

  // Do not pass the full `entry` via props in server output.
  // Non-serializable fields (like the `render` function) are stripped,
  // which causes runtime errors. Only return params here.
  return blogEntries.map((entry) => ({
    params: { slug: entry.slug },
  }));
};

// Fetch the entry at runtime to preserve the `render()` method in SSR
const slug = Astro.params.slug as string;
const entry = await getEntry("blog", slug);

if (!entry) {
  Astro.response.status = 404;
}

const { Content, headings } = entry
  ? await entry.render()
  : ({ Content: () => null, headings: [] } as any);

// Get all posts for related posts component
const allPosts = await getCollection("blog", ({ data }) => !data.draft);
---

{
  entry && (
    <BlogPost {...entry.data} headings={headings} slug={slug} allPosts={allPosts}>
      <Content />
    </BlogPost>
  )
}
