---
export interface Props {
  placeholder?: string;
  inline?: boolean;
  id?: string;
  label?: string;
}

const {
  placeholder = 'Search posts...',
  inline = false,
  id,
  label = 'Search posts'
} = Astro.props;

const instanceId = id ?? `search-${Math.random().toString(36).slice(2, 9)}`;
const inputId = `${instanceId}-input`;
const resultsId = `${instanceId}-results`;
const statusId = `${instanceId}-status`;
const loadingId = `${instanceId}-loading`;
---

<div
  class={`search-container ${inline ? 'search-inline' : ''}`}
  data-search-root
  data-search-id={instanceId}
>
  <div class="search-wrapper">
    <label class="sr-only" for={inputId}>{label}</label>
    <input
      type="text"
      id={inputId}
      placeholder={placeholder}
      class="search-input"
      autocomplete="off"
      aria-autocomplete="list"
      aria-controls={resultsId}
      aria-expanded="false"
      aria-describedby={statusId}
      aria-label={label}
      data-search-input
    />

    <div id={statusId} class="search-status" data-search-status role="status" aria-live="polite">
      Search titles, descriptions, and full content.
    </div>

    <div
      id={resultsId}
      class="search-results hidden"
      role="listbox"
      aria-label="Search results"
      data-search-results
    ></div>

    <div
      id={loadingId}
      class="search-loading hidden"
      data-search-loading
      role="status"
      aria-live="assertive"
    >
      Searching…
    </div>
  </div>
</div>

<script>
  import Fuse from 'fuse.js';

  type SearchIndexItem = {
    slug: string;
    title: string;
    description: string;
    content: string;
    tags: string[];
    pubDate: string;
    author: string;
  };

  type SearchState = {
    fuse: Fuse<SearchIndexItem> | null;
    loadingPromise: Promise<void> | null;
    index: SearchIndexItem[] | null;
  };

  declare global {
    interface Window {
      __nhSearchState?: SearchState;
    }
  }

  const root = document.currentScript?.closest('[data-search-root]') as HTMLElement | null;
  if (!root) {
    console.warn('Search root not found for search component.');
  } else {
    const input = root.querySelector<HTMLInputElement>('[data-search-input]');
    const results = root.querySelector<HTMLElement>('[data-search-results]');
    const loading = root.querySelector<HTMLElement>('[data-search-loading]');
    const status = root.querySelector<HTMLElement>('[data-search-status]');

    if (!input || !results || !loading || !status) {
      console.warn('Search component missing required elements.');
    } else {
      const globalState = window.__nhSearchState ?? (window.__nhSearchState = {
        fuse: null,
        loadingPromise: null,
        index: null
      });

      const DEFAULT_STATUS = 'Search titles, descriptions, and full content.';

      const showLoading = () => loading.classList.remove('hidden');
      const hideLoading = () => loading.classList.add('hidden');
      const setExpanded = (expanded: boolean) => {
        input.setAttribute('aria-expanded', expanded ? 'true' : 'false');
      };
      const setStatus = (message: string) => {
        status.textContent = message;
      };
      const resetStatus = () => {
        setStatus(DEFAULT_STATUS);
      };
      const clearResults = () => {
        results.innerHTML = '';
        results.classList.add('hidden');
        setExpanded(false);
      };

      const ensureFuse = async () => {
        if (globalState.fuse) return globalState.fuse;

        if (!globalState.loadingPromise) {
          globalState.loadingPromise = (async () => {
            const response = await fetch('/api/search-index.json');
            if (!response.ok) {
              throw new Error(`Failed to load search index: ${response.status}`);
            }
            const data = (await response.json()) as SearchIndexItem[];
            globalState.index = data;
            globalState.fuse = new Fuse(data, {
              keys: [
                { name: 'title', weight: 0.3 },
                { name: 'description', weight: 0.2 },
                { name: 'content', weight: 0.4 },
                { name: 'tags', weight: 0.1 }
              ],
              threshold: 0.3,
              includeScore: true,
              includeMatches: true,
              minMatchCharLength: 3,
              shouldSort: true,
              findAllMatches: true,
              ignoreLocation: true,
              useExtendedSearch: true,
              distance: 100000
            });
          })
            .catch((error) => {
              console.error('Failed to load search index:', error);
              globalState.fuse = null;
              throw error;
            })
            .finally(() => {
              globalState.loadingPromise = null;
            });
        }

        showLoading();
        try {
          await globalState.loadingPromise;
        } finally {
          hideLoading();
        }

        return globalState.fuse;
      };

      const escapeRegex = (text: string) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

      const highlightMatch = (text: string, query: string) => {
        const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
        return text.replace(regex, '<mark>$1</mark>');
      };
      const escapeHtml = (text: string) => {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      };

      const getSnippet = (content: string, query: string, maxLength = 160) => {
        const lowerContent = content.toLowerCase();
        const lowerQuery = query.toLowerCase();
        const index = lowerContent.indexOf(lowerQuery);

        if (index === -1) {
          return `${escapeHtml(content.substring(0, maxLength))}…`;
        }

        const start = Math.max(0, index - 60);
        const end = Math.min(content.length, index + query.length + 100);
        let snippet = content.substring(start, end);

        if (start > 0) snippet = `…${snippet}`;
        if (end < content.length) snippet = `${snippet}…`;

        return highlightMatch(escapeHtml(snippet), query);
      };

      const renderResults = (query: string) => {
        if (!globalState.fuse) return;

        const resultsList = globalState.fuse.search(query).slice(0, 12);

        if (resultsList.length === 0) {
          results.innerHTML = `
            <div class="search-no-results" role="option" tabindex="-1">
              No results found for “<strong>${escapeHtml(query)}</strong>”.
            </div>
          `;
          results.classList.remove('hidden');
          setExpanded(true);
          setStatus(`No results for “${query}”.`);
          return;
        }

        const html = resultsList.map((result) => {
          const item = result.item;
          const snippet = getSnippet(item.content, query);

          return `
            <a
              href="/blog/${item.slug}"
              class="search-result-item"
              role="option"
              tabindex="-1"
            >
              <div class="search-result-title">${highlightMatch(escapeHtml(item.title), query)}</div>
              <div class="search-result-snippet">${snippet}</div>
              <div class="search-result-meta">
                ${new Date(item.pubDate).toLocaleDateString()} • ${escapeHtml(item.author)}
                ${item.tags.length > 0 ? ` • ${item.tags.slice(0, 3).map(escapeHtml).join(', ')}` : ''}
              </div>
            </a>
          `;
        }).join('');

        results.innerHTML = html;
        results.classList.remove('hidden');
        setExpanded(true);
        setStatus(`Showing ${resultsList.length} result${resultsList.length === 1 ? '' : 's'} for “${query}”.`);
      };

      const performSearch = async (query: string) => {
        if (query.length < 2) {
          clearResults();
          if (query.length === 0) {
            resetStatus();
          } else {
            setStatus('Type at least 2 characters to search.');
          }
          return;
        }

        try {
          await ensureFuse();
          if (globalState.fuse) {
            renderResults(query);
          }
        } catch (error) {
          clearResults();
          setStatus('Search is unavailable. Please try again soon.');
        }
      };

      let debounceTimer: ReturnType<typeof setTimeout> | undefined;

      input.addEventListener('focus', async () => {
        try {
          await ensureFuse();
          setStatus('Type at least 2 characters to search.');
        } catch (error) {
          setStatus('Search is unavailable. Please try again soon.');
        }
      }, { once: true });

      input.addEventListener('input', (event) => {
        const query = (event.target as HTMLInputElement).value.trim();
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          void performSearch(query);
        }, 180);
      });

      input.addEventListener('keydown', (event) => {
        if (event.key === 'ArrowDown') {
          const firstResult = results.querySelector<HTMLAnchorElement>('a.search-result-item');
          if (firstResult) {
            event.preventDefault();
            firstResult.focus();
          }
        } else if (event.key === 'Escape') {
          clearResults();
          resetStatus();
        }
      });

      results.addEventListener('keydown', (event) => {
        const current = event.target as HTMLAnchorElement;
        if (event.key === 'ArrowDown') {
          const next = current.nextElementSibling as HTMLAnchorElement | null;
          if (next) {
            event.preventDefault();
            next.focus();
          }
        }
        if (event.key === 'ArrowUp') {
          const prev = current.previousElementSibling as HTMLAnchorElement | null;
          if (prev) {
            event.preventDefault();
            prev.focus();
          } else {
            event.preventDefault();
            input.focus();
          }
        }
        if (event.key === 'Escape') {
          clearResults();
          input.focus();
          resetStatus();
        }
      });

      document.addEventListener('click', (event) => {
        if (!root.contains(event.target as Node)) {
          clearResults();
        }
      });

      input.addEventListener('click', () => {
        if (results.innerHTML.trim()) {
          results.classList.remove('hidden');
          setExpanded(true);
        }
      });

      document.addEventListener('astro:before-swap', () => {
        clearResults();
      });
    }
  }
</script>

<style>
  .search-container {
    position: relative;
    width: 100%;
    max-width: 600px;
    margin: 0 auto;
  }

  .search-inline {
    max-width: 320px;
    margin: 0;
  }

  .search-wrapper {
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
  }

  .search-input {
    width: 100%;
    padding: 10px 14px;
    font-size: 15px;
    border: 1px solid #dbdbdb;
    border-radius: 6px;
    background-color: #ffffff;
    color: #171c26;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
    font-family: inherit;
  }

  .search-input::placeholder {
    color: #6b7280;
    font-size: 14px;
  }

  .search-input:focus {
    outline: none;
    border-color: #171c26;
    box-shadow: 0 0 0 2px rgba(23, 28, 38, 0.12);
  }

  .search-status {
    font-size: 0.85rem;
    color: #5b626b;
    min-height: 1.2rem;
  }

  .search-results {
    position: absolute;
    top: calc(100% + 0.5rem);
    left: 0;
    right: 0;
    background-color: #ffffff;
    border: 1px solid #dbdbdb;
    border-radius: 8px;
    box-shadow: 0 16px 32px rgba(0, 0, 0, 0.08);
    max-height: 420px;
    overflow-y: auto;
    z-index: 1000;
    padding: 0.5rem 0;
  }

  .search-results.hidden {
    display: none;
  }

  .search-loading {
    position: absolute;
    top: calc(100% + 0.5rem);
    left: 0;
    right: 0;
    padding: 12px 14px;
    background: white;
    border: 1px solid #dbdbdb;
    border-radius: 8px;
    text-align: center;
    color: #6b7280;
    font-size: 13px;
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.06);
  }

  .search-loading.hidden {
    display: none;
  }

  .search-result-item {
    display: block;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid #f2f2f2;
    text-decoration: none;
    color: #171c26;
    transition: background-color 0.15s ease;
    outline: none;
  }

  .search-result-item:last-child {
    border-bottom: none;
  }

  .search-result-item:hover,
  .search-result-item:focus {
    background-color: #f9fafb;
  }

  .search-result-title {
    font-weight: 600;
    font-size: 15px;
    color: #171c26;
    margin-bottom: 4px;
    line-height: 1.4;
  }

  .search-result-snippet {
    font-size: 13px;
    color: #5b626b;
    line-height: 1.5;
    margin-bottom: 4px;
  }

  .search-result-meta {
    font-size: 11px;
    color: #6b7280;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .search-no-results {
    padding: 1rem;
    text-align: center;
    color: #6b7280;
    font-size: 0.9rem;
  }

  mark {
    background-color: #e5fc81;
    color: #171c26;
    font-weight: 500;
    padding: 0 2px;
  }

  @media (max-width: 640px) {
    .search-results,
    .search-loading {
      position: fixed;
      left: 16px;
      right: 16px;
      top: 88px;
      max-height: calc(100vh - 120px);
    }

    .search-result-item {
      padding: 0.85rem 1rem;
    }
  }
</style>
